<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>圣诞快乐</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: 'Segoe UI', sans-serif;
            background: #000; 
            color: #fff;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }
        #container { 
            position: relative; 
            width: 100vw; 
            height: 100vh; 
        }
        #loading { 
            position: absolute; 
            top: 50%; 
            left: 50%; 
            transform: translate(-50%, -50%); 
            z-index: 100;
            text-align: center;
            font-size: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 30px;
            border-radius: 15px;
            border: 2px solid #0cf;
        }
        #webcamButton { 
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 24px;
            background: rgba(0, 200, 255, 0.8);
            border: none;
            border-radius: 30px;
            color: white;
            font-size: 16px;
            cursor: pointer;
            z-index: 10;
            transition: all 0.3s;
            font-weight: bold;
        }
        #webcamButton:hover { 
            background: rgba(0, 180, 235, 0.9);
            transform: translateX(-50%) scale(1.05);
        }
        #webcamButton:disabled { 
            background: rgba(100, 100, 100, 0.5);
            cursor: not-allowed;
            transform: translateX(-50%);
        }
        #debugCanvas { 
            position: absolute; 
            bottom: 20px; 
            left: 20px; 
            border: 2px solid rgba(0, 200, 255, 0.5);
            border-radius: 8px;
            transform: rotateY(180deg);
            z-index: 5;
        }
        #faceCanvas { 
            position: absolute; 
            bottom: 20px; 
            left: 360px; 
            border: 2px solid rgba(255, 200, 0, 0.5);
            border-radius: 8px;
            transform: rotateY(180deg);
            z-index: 5;
        }
        #gestureInfo {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            min-width: 200px;
            z-index: 10;
            backdrop-filter: blur(5px);
        }
        #gestureInfo h3 { 
            color: #0cf;
            margin-bottom: 10px;
            border-bottom: 1px solid rgba(0, 200, 255, 0.3);
            padding-bottom: 5px;
            text-align: center;
        }
        .gesture-item { 
            margin: 8px 0; 
            display: flex; 
            align-items: center;
            padding: 5px 10px;
            border-radius: 5px;
            transition: all 0.3s;
        }
        .gesture-item:hover {
            background: rgba(0, 200, 255, 0.1);
        }
        .gesture-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 10px;
            background: #666;
            transition: all 0.3s;
        }
        .gesture-indicator.active { 
            background: #0cf;
            box-shadow: 0 0 10px #0cf;
            animation: pulse 1.5s infinite;
        }
        @keyframes pulse {
            0% { box-shadow: 0 0 5px #0cf; }
            50% { box-shadow: 0 0 15px #0cf; }
            100% { box-shadow: 0 0 5px #0cf; }
        }
        #faceInfo {
            position: absolute;
            top: 300px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            min-width: 200px;
            z-index: 10;
            backdrop-filter: blur(5px);
        }
        #faceInfo h3 { 
            color: #ffcc00;
            margin-bottom: 10px;
            border-bottom: 1px solid rgba(255, 200, 0, 0.3);
            padding-bottom: 5px;
            text-align: center;
        }
        .face-indicator {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            margin-right: 10px;
            background: #666;
            transition: all 0.3s;
        }
        .face-indicator.active { 
            background: #ffcc00;
            box-shadow: 0 0 15px #ffcc00;
            animation: smilePulse 1s infinite;
        }
        @keyframes smilePulse {
            0% { box-shadow: 0 0 5px #ffcc00; }
            50% { box-shadow: 0 0 20px #ffcc00; }
            100% { box-shadow: 0 0 5px #ffcc00; }
        }
        #particleCount {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 8px;
            font-size: 14px;
            z-index: 10;
            backdrop-filter: blur(5px);
        }
        #status {
            position: absolute;
            top: 70px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 14px;
            z-index: 10;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(0, 200, 255, 0.3);
        }
        #permissionWarning {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            border: 2px solid #f00;
            z-index: 100;
            display: none;
            max-width: 400px;
            width: 90%;
        }
        #permissionWarning p { 
            color: #f00; 
            font-size: 18px; 
            margin-bottom: 15px;
        }
        #permissionWarning button {
            margin-top: 15px;
            padding: 10px 20px;
            background: #f00;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
        }
        #permissionWarning button:hover {
            background: #c00;
        }
        .instructions {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 8px;
            font-size: 12px;
            width: 80%;
            max-width: 600px;
        }
        #fpsCounter {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 12px;
            z-index: 10;
        }
        @media (max-width: 768px) {
            #debugCanvas, #faceCanvas { 
                width: 140px; 
                height: 105px; 
            }
            #faceCanvas { left: 180px; }
            #gestureInfo, #faceInfo { 
                top: auto; 
                bottom: 150px; 
                right: 20px; 
                left: 20px;
            }
            #faceInfo { top: 350px; }
            #status { top: 60px; font-size: 12px; }
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="loading">加载圣诞氛围中...</div>
        <button id="webcamButton">启动摄像头</button>
        <div id="status">等待摄像头启动...</div>
        <canvas id="debugCanvas" width="320" height="240"></canvas>
        <canvas id="faceCanvas" width="320" height="240"></canvas>
        <div id="gestureInfo">
            <h3>手势控制</h3>
            <div class="gesture-item"><div class="gesture-indicator" id="indicator-open"></div>张手 - 粒子球</div>
            <div class="gesture-item"><div class="gesture-indicator" id="indicator-scissors"></div>剪刀手 - "我是 Vick"</div>
            <div class="gesture-item"><div class="gesture-indicator" id="indicator-fist"></div>握拳 - 圆环</div>
            <div class="gesture-item"><div class="gesture-indicator" id="indicator-point"></div>食指 - 星星</div>
            <div class="gesture-item"><div class="gesture-indicator" id="indicator-thumb"></div>竖大拇指 - 爱心</div>
        </div>
        <div id="faceInfo">
            <h3>面部表情</h3>
            <div class="gesture-item"><div class="face-indicator" id="indicator-smile"></div>微笑 - 显示圣诞树</div>
            <div id="smileValue">微笑程度: <span id="smile-level">0</span>%</div>
        </div>
        <div id="particleCount">粒子数: <span id="count">0</span></div>
        <div id="fpsCounter">FPS: <span id="fps">0</span></div>
        <div class="instructions">
            提示：在摄像头前展示不同手势，快速挥手可产生风暴效果，手靠近/远离可控制粒子大小，微笑可以召唤圣诞树！
        </div>
        <div id="permissionWarning">
            <p>需要摄像头权限以实现手部检测</p>
            <p>请刷新页面并允许摄像头访问</p>
            <button onclick="location.reload()">刷新页面</button>
        </div>
    </div>

    <!-- Three.js 库 -->
    <script src="https://unpkg.com/three@0.135.0/build/three.min.js"></script>
    <script src="https://unpkg.com/three@0.135.0/examples/js/controls/OrbitControls.js"></script>
    
    <!-- MediaPipe 库 -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    
    <script>
        // ============ 全局变量声明 ============
        let scene, camera, renderer, controls;
        let particleSystem;
        let hands = null;
        let faceMesh = null;
        let video = null;
        let handCanvasCtx = null;
        let faceCanvasCtx = null;
        let animationId = null;
        let lastTime = 0;
        let frameCount = 0;
        let fps = 0;
        
        // 物理参数
        const PARTICLE_COUNT = 16000;
        const ATTRACTION_FORCE = 0.2;
        const REPULSION_FORCE = 0.5;
        const DAMPING = 0.95;
        const MAX_VELOCITY = 5;
        
        // 手势状态
        const GESTURE_STATES = {
            NONE: 0,
            OPEN_HAND: 1,
            SCISSORS: 2,
            FIST: 3,
            POINTING: 4,
            THUMBS_UP: 5,
            CHRISTMAS_TREE: 6  // 微笑时的圣诞树形状
        };
        
        let currentGesture = GESTURE_STATES.NONE;
        let targetGesture = GESTURE_STATES.NONE;
        let gestureTransitionProgress = 0;
        let gestureTransitionSpeed = 0.3; // 加快过渡速度（原来是0.1）
        
        // 面部状态
        let isSmiling = false;
        let smileLevel = 0;
        let christmasTree = null;
        let treeRotationSpeed = 0.005;
        
        // 手部数据
        let handData = {
            landmarks: null,
            velocity: { x: 0, y: 0, z: 0 },
            prevPosition: { x: 0, y: 0, z: 0 },
            handSize: 0,
            palmCenter: { x: 0, y: 0, z: 0 }
        };
        
        // 粒子数据
        let particleData = {
            positions: null,
            velocities: null,
            accelerations: null,
            targets: null,
            colors: null,
            states: null
        };

        // ============ Three.js 初始化 ============
        function initThreeJS() {
            console.log("初始化Three.js场景...");
            try {
                // 创建场景
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x0d4a0d); // 深圣诞绿背景（像圣诞树）
                
                // 添加星空背景
                createStarfield();
                
                // 相机设置
                camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.z = 15;
                
                // 渲染器设置
                renderer = new THREE.WebGLRenderer({ 
                    antialias: true, 
                    alpha: true,
                    powerPreference: "high-performance"
                });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                document.getElementById('container').appendChild(renderer.domElement);
                
                // 轨道控制器
                controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.enabled = false;
                
                // 灯光系统
                setupLighting();
                
                // 初始化粒子数据
                initParticleData();
                
                // 创建粒子系统
                createParticleSystem();
                
                // 窗口大小调整监听
                window.addEventListener('resize', onWindowResize);
                
                document.getElementById('loading').style.display = 'none';
                console.log("Three.js初始化完成");
            } catch (error) {
                console.error("Three.js初始化失败:", error);
                document.getElementById('loading').innerHTML = "Three.js初始化失败，请刷新页面重试";
            }
        }
        
        // 创建星空背景
        function createStarfield() {
            const starGeometry = new THREE.BufferGeometry();
            const starCount = 2000;
            const positions = new Float32Array(starCount * 3);
            
            for (let i = 0; i < starCount * 3; i += 3) {
                positions[i] = (Math.random() - 0.5) * 2000;
                positions[i + 1] = (Math.random() - 0.5) * 2000;
                positions[i + 2] = (Math.random() - 0.5) * 2000;
            }
            
            starGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            const starMaterial = new THREE.PointsMaterial({
                color: 0xFFFFFF,
                size: 0.7,
                sizeAttenuation: true
            });
            
            const stars = new THREE.Points(starGeometry, starMaterial);
            scene.add(stars);
        }
        
        // 设置灯光
        function setupLighting() {
            // 环境光
            const ambientLight = new THREE.AmbientLight(0x333333);
            scene.add(ambientLight);
            
            // 主光源
            const mainLight = new THREE.DirectionalLight(0xffffff, 0.8);
            mainLight.position.set(10, 20, 15);
            scene.add(mainLight);
            
            // 补光
            const fillLight = new THREE.DirectionalLight(0xaaaaaa, 0.3);
            fillLight.position.set(-10, -10, -5);
            scene.add(fillLight);
            
            // 青色氛围光
            const cyanLight = new THREE.PointLight(0x00ffff, 0.5, 50);
            cyanLight.position.set(0, 5, 10);
            scene.add(cyanLight);
        }
        
        // 初始化粒子数据
        function initParticleData() {
            console.log(`初始化${PARTICLE_COUNT}个粒子数据...`);
            particleData = {
                positions: new Float32Array(PARTICLE_COUNT * 3),
                velocities: new Float32Array(PARTICLE_COUNT * 3),
                accelerations: new Float32Array(PARTICLE_COUNT * 3),
                targets: new Float32Array(PARTICLE_COUNT * 3),
                colors: new Float32Array(PARTICLE_COUNT * 3),
                states: new Array(PARTICLE_COUNT).fill(0)
            };
            
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;
                // 随机初始位置
                particleData.positions[i3] = (Math.random() - 0.5) * 20;
                particleData.positions[i3 + 1] = (Math.random() - 0.5) * 20;
                particleData.positions[i3 + 2] = (Math.random() - 0.5) * 20;
                
                // 圣诞主题颜色：70%红色，30%金色
                if (Math.random() < 0.7) {
                    // 红色粒子（圣诞装饰品）
                    particleData.colors[i3] = 1;      // 红色
                    particleData.colors[i3 + 1] = 0.1; // 少量绿色
                    particleData.colors[i3 + 2] = 0.1; // 少量蓝色
                } else {
                    // 金色粒子（星星、灯光）
                    particleData.colors[i3] = 1;      // 红色
                    particleData.colors[i3 + 1] = 0.8; // 金色（红+绿）
                    particleData.colors[i3 + 2] = 0.2; // 少量蓝色
                }
                
                // 随机初始速度
                particleData.velocities[i3] = (Math.random() - 0.5) * 0.1;
                particleData.velocities[i3 + 1] = (Math.random() - 0.5) * 0.1;
                particleData.velocities[i3 + 2] = (Math.random() - 0.5) * 0.1;
                
                // 初始目标位置
                particleData.targets[i3] = particleData.positions[i3];
                particleData.targets[i3 + 1] = particleData.positions[i3 + 1];
                particleData.targets[i3 + 2] = particleData.positions[i3 + 2];
            }
        }
        
        // 创建粒子系统
        function createParticleSystem() {
            console.log("创建粒子系统...");
            try {
                const geometry = new THREE.BufferGeometry();
                
                geometry.setAttribute('position', new THREE.BufferAttribute(particleData.positions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(particleData.colors, 3));
                
                // 粒子材质
                const material = new THREE.PointsMaterial({
                    size: 0.05,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.8,
                    blending: THREE.AdditiveBlending,
                    sizeAttenuation: true
                });
                
                // 创建粒子系统
                particleSystem = new THREE.Points(geometry, material);
                scene.add(particleSystem);
                
                // 更新粒子数量显示
                document.getElementById('count').textContent = PARTICLE_COUNT.toLocaleString();
                console.log("粒子系统创建完成");
            } catch (error) {
                console.error("粒子系统创建失败:", error);
            }
        }
        
        // ============ MediaPipe 初始化 ============
        
        // 启动摄像头
        async function startWebcam() {
            console.log("启动摄像头...");
            const button = document.getElementById('webcamButton');
            const status = document.getElementById('status');
            
            button.disabled = true;
            button.textContent = '启动中...';
            status.textContent = '正在请求摄像头权限...';
            
            // 检查摄像头可用性
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                status.textContent = '浏览器不支持摄像头访问';
                document.getElementById('permissionWarning').style.display = 'block';
                return;
            }
            
            try {
                // 获取摄像头权限
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { 
                        width: { ideal: 640 }, 
                        height: { ideal: 480 },
                        facingMode: 'user' 
                    } 
                });
                
                // 创建视频元素
                video = document.createElement('video');
                video.srcObject = stream;
                video.playsInline = true;
                video.autoplay = true;
                video.muted = true; // 静音以避免自动播放限制
                video.style.display = 'none';
                document.body.appendChild(video);
                
                // 等待视频数据加载并开始播放
                await new Promise((resolve, reject) => {
                    const timeout = setTimeout(() => {
                        reject(new Error('视频加载超时'));
                    }, 5000);
                    
                    video.onloadeddata = () => {
                        // 确保视频开始播放
                        video.play().then(() => {
                            clearTimeout(timeout);
                            resolve();
                        }).catch(reject);
                    };
                    
                    video.onerror = (e) => {
                        clearTimeout(timeout);
                        reject(new Error('视频加载失败'));
                    };
                });
                
                // 初始化调试画布
                const debugCanvas = document.getElementById('debugCanvas');
                handCanvasCtx = debugCanvas.getContext('2d');
                
                const faceCanvas = document.getElementById('faceCanvas');
                faceCanvasCtx = faceCanvas.getContext('2d');
                
                status.textContent = '初始化手部和面部检测...';
                
                // 初始化MediaPipe
                await initMediaPipe();
                
                button.style.display = 'none';
                status.textContent = '检测已激活 - 请展示手势或微笑';
                
                // 开始处理视频
                processVideo();
                
            } catch (error) {
                console.error('摄像头启动失败:', error);
                status.textContent = '摄像头启动失败: ' + error.message;
                document.getElementById('permissionWarning').style.display = 'block';
                button.disabled = false;
                button.textContent = '启动摄像头';
            }
        }
        
        // 初始化MediaPipe
        async function initMediaPipe() {
            console.log("初始化MediaPipe...");
            
            try {
                // 初始化手部检测
                hands = new Hands({
                    locateFile: (file) => {
                        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
                    }
                });
                
                hands.setOptions({
                    maxNumHands: 1,
                    modelComplexity: 1,
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });
                
                hands.onResults(onHandResults);
                
                // 初始化面部检测
                faceMesh = new FaceMesh({
                    locateFile: (file) => {
                        return `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`;
                    }
                });
                
                faceMesh.setOptions({
                    maxNumFaces: 1,
                    refineLandmarks: true,
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });
                
                faceMesh.onResults(onFaceResults);
                
                console.log("MediaPipe初始化完成");
            } catch (error) {
                console.error("MediaPipe初始化失败:", error);
                throw error;
            }
        }
        
        // 处理视频帧
        async function processVideo() {
            if (!video || video.readyState < 2) {
                setTimeout(processVideo, 100);
                return;
            }
            
            try {
                // 交替处理手部和面部检测以提升性能
                if (frameCount % 2 === 0) {
                    await hands.send({image: video});
                } else {
                    await faceMesh.send({image: video});
                }
            } catch (error) {
                console.error("视频处理失败:", error);
            }
            
            requestAnimationFrame(processVideo);
        }
        
        // 处理手部检测结果
        function onHandResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                handData.landmarks = results.multiHandLandmarks[0];
                
                // 计算手掌中心点
                const palmPoints = [0, 1, 5, 9, 13, 17];
                handData.palmCenter.x = 0;
                handData.palmCenter.y = 0;
                handData.palmCenter.z = 0;
                
                palmPoints.forEach(idx => {
                    handData.palmCenter.x += handData.landmarks[idx].x;
                    handData.palmCenter.y += handData.landmarks[idx].y;
                    handData.palmCenter.z += handData.landmarks[idx].z;
                });
                
                handData.palmCenter.x /= palmPoints.length;
                handData.palmCenter.y /= palmPoints.length;
                handData.palmCenter.z /= palmPoints.length;
                
                // 计算手部速度
                const currentPos = {
                    x: handData.palmCenter.x,
                    y: handData.palmCenter.y,
                    z: handData.palmCenter.z
                };
                
                handData.velocity.x = (currentPos.x - handData.prevPosition.x) * 0.3;
                handData.velocity.y = (currentPos.y - handData.prevPosition.y) * 0.3;
                handData.velocity.z = (currentPos.z - handData.prevPosition.z) * 0.3;
                
                handData.prevPosition = { ...currentPos };
                
                // 计算手掌大小
                const wrist = handData.landmarks[0];
                const middleFingerTip = handData.landmarks[12];
                handData.handSize = Math.sqrt(
                    Math.pow(wrist.x - middleFingerTip.x, 2) +
                    Math.pow(wrist.y - middleFingerTip.y, 2) +
                    Math.pow(wrist.z - middleFingerTip.z, 2)
                );
                
                // 识别手势
                detectGesture();
                
                // 在调试画布上绘制手部关键点
                if (handCanvasCtx && video && video.readyState >= 2) {
                    handCanvasCtx.save();
                    handCanvasCtx.clearRect(0, 0, 320, 240);
                    
                    // 先翻转画布
                    handCanvasCtx.scale(-1, 1);
                    handCanvasCtx.translate(-320, 0);
                    
                    // 绘制视频（翻转后）
                    handCanvasCtx.drawImage(video, 0, 0, 320, 240);
                    
                    // 绘制手部关键点和连接线
                    if (typeof drawConnectors !== 'undefined' && typeof HAND_CONNECTIONS !== 'undefined') {
                        drawConnectors(handCanvasCtx, handData.landmarks, HAND_CONNECTIONS, {
                            color: '#00FF00',
                            lineWidth: 2
                        });
                        drawLandmarks(handCanvasCtx, handData.landmarks, {
                            color: '#FF0000',
                            lineWidth: 1,
                            radius: 3
                        });
                    }
                    
                    handCanvasCtx.restore();
                }
            } else {
                handData.landmarks = null;
                targetGesture = GESTURE_STATES.NONE;
                updateGestureIndicators();
                
                // 即使没有检测到手部，也要绘制视频
                if (handCanvasCtx && video && video.readyState >= 2) {
                    handCanvasCtx.save();
                    handCanvasCtx.clearRect(0, 0, 320, 240);
                    handCanvasCtx.scale(-1, 1);
                    handCanvasCtx.translate(-320, 0);
                    handCanvasCtx.drawImage(video, 0, 0, 320, 240);
                    handCanvasCtx.restore();
                }
            }
        }
        
        // 处理面部检测结果
        function onFaceResults(results) {
            if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
                const landmarks = results.multiFaceLandmarks[0];
                
                // 获取嘴部关键点索引
                // MediaPipe Face Mesh的嘴部关键点索引
                const topLip = landmarks[13];      // 上唇中部
                const bottomLip = landmarks[14];   // 下唇中部
                const leftMouthCorner = landmarks[61];    // 左嘴角
                const rightMouthCorner = landmarks[291];  // 右嘴角
                
                // 计算嘴角距离（微笑时变宽）
                const mouthWidth = Math.sqrt(
                    Math.pow(rightMouthCorner.x - leftMouthCorner.x, 2) +
                    Math.pow(rightMouthCorner.y - leftMouthCorner.y, 2)
                );
                
                // 计算上下唇距离
                const mouthOpen = Math.sqrt(
                    Math.pow(bottomLip.x - topLip.x, 2) +
                    Math.pow(bottomLip.y - topLip.y, 2)
                );
                
                // 计算微笑程度 (0-100%)
                const mouthWidthBase = 0.1;  // 基准宽度
                const mouthOpenBase = 0.02;  // 基准开口
                
                const widthFactor = Math.min((mouthWidth - mouthWidthBase) * 3, 1);
                const openFactor = Math.min((mouthOpen - mouthOpenBase) * 10, 1);
                
                const newSmileLevel = Math.max(0, Math.min(100, (widthFactor * 0.7 + openFactor * 0.3) * 100));
                smileLevel = newSmileLevel;
                
                // 判断是否微笑 (阈值设为5%)
                const newIsSmiling = smileLevel > 5;
                
                // 如果微笑，让粒子形成圣诞树形状
                if (newIsSmiling) {
                    targetGesture = GESTURE_STATES.CHRISTMAS_TREE;
                    if (!isSmiling) {
                        showChristmasTree();
                    }
                } else if (isSmiling) {
                    // 停止微笑，恢复默认状态
                    targetGesture = GESTURE_STATES.NONE;
                    hideChristmasTree();
                }
                
                isSmiling = newIsSmiling;
                
                // 更新UI
                document.getElementById('smile-level').textContent = Math.round(smileLevel);
                const smileIndicator = document.getElementById('indicator-smile');
                if (isSmiling) {
                    smileIndicator.classList.add('active');
                } else {
                    smileIndicator.classList.remove('active');
                }
                
                // 在面部画布上绘制关键点
                if (faceCanvasCtx && video && video.readyState >= 2) {
                    faceCanvasCtx.save();
                    faceCanvasCtx.clearRect(0, 0, 320, 240);
                    
                    // 先翻转画布
                    faceCanvasCtx.scale(-1, 1);
                    faceCanvasCtx.translate(-320, 0);
                    
                    // 绘制视频（翻转后）
                    faceCanvasCtx.drawImage(video, 0, 0, 320, 240);
                    
                    // 绘制嘴部关键点
                    const mouthPoints = [13, 14, 61, 291];
                    mouthPoints.forEach(idx => {
                        const point = landmarks[idx];
                        faceCanvasCtx.beginPath();
                        faceCanvasCtx.arc(point.x * 320, point.y * 240, 4, 0, 2 * Math.PI);
                        faceCanvasCtx.fillStyle = isSmiling ? '#ffcc00' : '#ff6666';
                        faceCanvasCtx.fill();
                    });
                    
                    faceCanvasCtx.restore();
                    
                    // 绘制微笑程度文字（不翻转）
                    faceCanvasCtx.save();
                    faceCanvasCtx.fillStyle = isSmiling ? '#ffcc00' : '#ffffff';
                    faceCanvasCtx.font = 'bold 16px Arial';
                    faceCanvasCtx.fillText(`微笑: ${Math.round(smileLevel)}%`, 10, 30);
                    faceCanvasCtx.restore();
                }
            } else {
                // 未检测到面部
                if (isSmiling) {
                    hideChristmasTree();
                    isSmiling = false;
                }
                smileLevel = 0;
                document.getElementById('smile-level').textContent = '0';
                document.getElementById('indicator-smile').classList.remove('active');
                
                // 即使没有检测到面部，也要绘制视频
                if (faceCanvasCtx && video && video.readyState >= 2) {
                    faceCanvasCtx.save();
                    faceCanvasCtx.clearRect(0, 0, 320, 240);
                    faceCanvasCtx.scale(-1, 1);
                    faceCanvasCtx.translate(-320, 0);
                    faceCanvasCtx.drawImage(video, 0, 0, 320, 240);
                    faceCanvasCtx.restore();
                    
                    // 绘制微笑程度文字
                    faceCanvasCtx.save();
                    faceCanvasCtx.fillStyle = '#ffffff';
                    faceCanvasCtx.font = 'bold 16px Arial';
                    faceCanvasCtx.fillText(`微笑: 0%`, 10, 30);
                    faceCanvasCtx.restore();
                }
            }
        }
        
        // ============ 手势识别 ============
        
        // 手势识别函数
        function detectGesture() {
            if (!handData.landmarks) return;
            
            const thumbTip = handData.landmarks[4];
            const indexTip = handData.landmarks[8];
            const middleTip = handData.landmarks[12];
            const ringTip = handData.landmarks[16];
            const pinkyTip = handData.landmarks[20];
            const wrist = handData.landmarks[0];
            
            // 计算手指张开程度
            const fingersExtended = [
                isFingerExtended(thumbTip, handData.landmarks[2], wrist),
                isFingerExtended(indexTip, handData.landmarks[6], wrist),
                isFingerExtended(middleTip, handData.landmarks[10], wrist),
                isFingerExtended(ringTip, handData.landmarks[14], wrist),
                isFingerExtended(pinkyTip, handData.landmarks[18], wrist)
            ];
            
            const extendedCount = fingersExtended.filter(extended => extended).length;
            
            // 手势判断逻辑
            if (extendedCount === 5) {
                targetGesture = GESTURE_STATES.OPEN_HAND;
            } else if (fingersExtended[1] && fingersExtended[2] && 
                      !fingersExtended[0] && !fingersExtended[3] && !fingersExtended[4]) {
                targetGesture = GESTURE_STATES.SCISSORS;
            } else if (extendedCount <= 1) {
                targetGesture = GESTURE_STATES.FIST;
            } else if (fingersExtended[1] && !fingersExtended[2] && 
                      !fingersExtended[3] && !fingersExtended[4]) {
                targetGesture = GESTURE_STATES.POINTING;
            } else if (fingersExtended[0] && !fingersExtended[1] && 
                      !fingersExtended[2] && !fingersExtended[3] && !fingersExtended[4]) {
                targetGesture = GESTURE_STATES.THUMBS_UP;
            } else {
                targetGesture = GESTURE_STATES.NONE;
            }
            
            updateGestureIndicators();
        }
        
        // 判断手指是否伸直
        function isFingerExtended(tip, pip, wrist) {
            const tipToPip = Math.sqrt(
                Math.pow(tip.x - pip.x, 2) +
                Math.pow(tip.y - pip.y, 2) +
                Math.pow(tip.z - pip.z, 2)
            );
            
            const pipToWrist = Math.sqrt(
                Math.pow(pip.x - wrist.x, 2) +
                Math.pow(pip.y - wrist.y, 2) +
                Math.pow(pip.z - wrist.z, 2)
            );
            
            return tipToPip > pipToWrist * 0.3;
        }
        
        // 更新手势指示器UI
        function updateGestureIndicators() {
            const indicators = ['open', 'scissors', 'fist', 'point', 'thumb'];
            
            indicators.forEach((gesture, index) => {
                const indicator = document.getElementById(`indicator-${gesture}`);
                if (indicator) {
                    if (targetGesture === index + 1) {
                        indicator.classList.add('active');
                    } else {
                        indicator.classList.remove('active');
                    }
                }
            });
        }
        
        // ============ 圣诞树功能 ============
        
        // 创建圣诞树
        function createChristmasTree() {
            const treeGroup = new THREE.Group();
            treeGroup.name = "christmasTree";
            
            // 1. 创建树干（棕色圆柱体）
            const trunkGeometry = new THREE.CylinderGeometry(0.2, 0.25, 1.5, 8);
            const trunkMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x8B4513,
                roughness: 0.9,
                metalness: 0.1
            });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.y = 0.75;
            treeGroup.add(trunk);
            
            // 2. 创建树叶层（多个绿色锥体）
            const leafColor = 0x228B22;
            const levels = 5;
            for (let i = 0; i < levels; i++) {
                const radius = 1.5 - i * 0.25;
                const height = 1.8;
                const coneGeometry = new THREE.ConeGeometry(radius, height, 8);
                const coneMaterial = new THREE.MeshStandardMaterial({ 
                    color: leafColor,
                    roughness: 0.8,
                    metalness: 0.2
                });
                const cone = new THREE.Mesh(coneGeometry, coneMaterial);
                cone.position.y = 1.5 + i * 1.5;
                treeGroup.add(cone);
            }
            
            // 3. 添加装饰小球（彩色球体）
            const ballColors = [0xFF0000, 0x00FF00, 0x0000FF, 0xFFFF00, 0xFF00FF, 0x00FFFF];
            const ballPositions = [
                [0, 4.0, 0.4], [0.4, 5.0, 0.2], [-0.3, 6.0, 0], 
                [0.2, 3.0, 0.5], [-0.4, 2.0, 0.3], [0.3, 7.0, -0.2],
                [-0.2, 4.5, -0.3], [0.5, 3.5, -0.2], [-0.5, 5.5, 0.3]
            ];
            
            ballPositions.forEach((pos, index) => {
                const ballGeometry = new THREE.SphereGeometry(0.15, 16, 16);
                const ballMaterial = new THREE.MeshStandardMaterial({ 
                    color: ballColors[index % ballColors.length],
                    emissive: ballColors[index % ballColors.length],
                    emissiveIntensity: 0.2,
                    roughness: 0.3,
                    metalness: 0.7
                });
                const ball = new THREE.Mesh(ballGeometry, ballMaterial);
                ball.position.set(pos[0], pos[1], pos[2]);
                treeGroup.add(ball);
                
                // 为小球添加动画属性
                ball.userData = {
                    originalY: pos[1],
                    floatSpeed: 0.02 + Math.random() * 0.02,
                    floatHeight: 0.1 + Math.random() * 0.1,
                    rotationSpeed: 0.01 + Math.random() * 0.02
                };
            });
            
            // 4. 添加一颗星星在树顶
            const starGeometry = createStarGeometry(0, 0.5, 0.3, 5);
            const starMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xFFD700,
                emissive: 0xFFD700,
                emissiveIntensity: 0.5,
                roughness: 0.2,
                metalness: 0.8
            });
            const star = new THREE.Mesh(starGeometry, starMaterial);
            star.position.y = 9.5;
            treeGroup.add(star);
            
            // 5. 添加雪花特效
            createSnowEffect(treeGroup);
            
            // 设置整棵树的位置（放在场景右侧）
            treeGroup.position.set(12, -5, -10);
            treeGroup.scale.set(0.7, 0.7, 0.7);
            
            // 为树添加动画属性
            treeGroup.userData = {
                floatTime: 0,
                rotationTime: 0,
                originalY: treeGroup.position.y
            };
            
            return treeGroup;
        }
        
        // 创建星星几何体
        function createStarGeometry(innerRadius, outerRadius, height, points) {
            const shape = new THREE.Shape();
            const step = Math.PI * 2 / points;
            
            for (let i = 0; i < points * 2; i++) {
                const radius = i % 2 === 0 ? outerRadius : innerRadius;
                const angle = i * step / 2;
                const x = Math.cos(angle) * radius;
                const y = Math.sin(angle) * radius;
                
                if (i === 0) {
                    shape.moveTo(x, y);
                } else {
                    shape.lineTo(x, y);
                }
            }
            shape.closePath();
            
            const extrudeSettings = {
                depth: height,
                bevelEnabled: true,
                bevelThickness: 0.1,
                bevelSize: 0.1,
                bevelSegments: 3
            };
            
            return new THREE.ExtrudeGeometry(shape, extrudeSettings);
        }
        
        // 创建雪花特效
        function createSnowEffect(treeGroup) {
            const snowCount = 30;
            const snowGeometry = new THREE.SphereGeometry(0.05, 8, 8);
            const snowMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xFFFFFF,
                transparent: true,
                opacity: 0.8
            });
            
            for (let i = 0; i < snowCount; i++) {
                const snow = new THREE.Mesh(snowGeometry, snowMaterial);
                
                // 随机位置在树周围
                const angle = Math.random() * Math.PI * 2;
                const radius = 2 + Math.random() * 3;
                const height = 2 + Math.random() * 7;
                
                snow.position.set(
                    Math.cos(angle) * radius,
                    height,
                    Math.sin(angle) * radius
                );
                
                // 为雪花添加动画属性
                snow.userData = {
                    originalY: height,
                    floatSpeed: 0.01 + Math.random() * 0.02,
                    floatHeight: 0.2 + Math.random() * 0.2,
                    rotationSpeed: 0.005 + Math.random() * 0.01,
                    angle: angle,
                    radius: radius
                };
                
                treeGroup.add(snow);
            }
        }
        
        // 更新圣诞树动画
        function updateChristmasTree() {
            if (!christmasTree) return;
            
            const time = Date.now() * 0.001;
            
            // 整体浮动效果
            christmasTree.userData.floatTime += 0.01;
            christmasTree.userData.rotationTime += treeRotationSpeed;
            
            christmasTree.position.y = christmasTree.userData.originalY + 
                                      Math.sin(christmasTree.userData.floatTime) * 0.3;
            
            christmasTree.rotation.y = christmasTree.userData.rotationTime;
            
            // 更新装饰小球动画
            christmasTree.children.forEach(child => {
                if (child.geometry instanceof THREE.SphereGeometry && child.userData) {
                    // 浮动效果
                    child.position.y = child.userData.originalY + 
                                      Math.sin(time * child.userData.floatSpeed) * child.userData.floatHeight;
                    
                    // 旋转效果
                    child.rotation.x += child.userData.rotationSpeed;
                    child.rotation.y += child.userData.rotationSpeed * 0.7;
                    
                    // 闪烁效果
                    const intensity = 0.3 + Math.sin(time * 3) * 0.2;
                    child.material.emissiveIntensity = intensity;
                }
                
                // 更新雪花动画
                if (child.geometry && child.geometry.type === "SphereGeometry" && 
                    child.material.color.getHex() === 0xFFFFFF && child.userData) {
                    child.userData.angle += 0.005;
                    child.position.x = Math.cos(child.userData.angle) * child.userData.radius;
                    child.position.z = Math.sin(child.userData.angle) * child.userData.radius;
                    
                    child.position.y = child.userData.originalY + 
                                      Math.sin(time * child.userData.floatSpeed) * child.userData.floatHeight;
                    
                    child.rotation.x += child.userData.rotationSpeed;
                    child.rotation.y += child.userData.rotationSpeed;
                    
                    // 随机改变不透明度
                    child.material.opacity = 0.6 + Math.sin(time * 2 + child.userData.angle) * 0.2;
                }
            });
        }
        
        // 显示圣诞树（粒子形状）
        function showChristmasTree() {
            // 显示提示信息
            const status = document.getElementById('status');
            status.textContent = '检测到微笑！粒子正在形成圣诞树！';
            status.style.color = '#ffcc00';
            
            setTimeout(() => {
                if (isSmiling) {
                    status.textContent = '保持微笑，圣诞树会一直存在！';
                }
            }, 2000);
            
            console.log("检测到微笑！粒子正在形成圣诞树！");
        }
        
        // 隐藏圣诞树（粒子形状）
        function hideChristmasTree() {
            // 恢复状态提示
            const status = document.getElementById('status');
            status.textContent = '微笑消失，圣诞树消失了。';
            status.style.color = '#ffffff';
            
            setTimeout(() => {
                status.textContent = '检测已激活 - 请展示手势或微笑';
            }, 2000);
            
            console.log("微笑消失，圣诞树消失。");
        }
        
        // ============ 粒子系统更新 ============
        
        // 物理模拟和粒子更新
        function updateParticles() {
            if (!particleSystem) return;
            
            const positions = particleSystem.geometry.attributes.position.array;
            const colors = particleSystem.geometry.attributes.color.array;
            
            // 平滑过渡手势状态
            if (currentGesture !== targetGesture) {
                gestureTransitionProgress += gestureTransitionSpeed;
                if (gestureTransitionProgress >= 1) {
                    currentGesture = targetGesture;
                    gestureTransitionProgress = 0;
                    
                    // 触发爆炸过渡特效
                    if (currentGesture !== GESTURE_STATES.NONE) {
                        applyExplosionEffect();
                    }
                }
            }
            
            // 根据当前手势计算目标形状
            calculateTargetShape();
            
            // 更新每个粒子的物理状态
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;
                
                // 计算目标吸引力
                const targetX = particleData.targets[i3];
                const targetY = particleData.targets[i3 + 1];
                const targetZ = particleData.targets[i3 + 2];
                
                // 计算当前距离目标的向量
                const dx = targetX - particleData.positions[i3];
                const dy = targetY - particleData.positions[i3 + 1];
                const dz = targetZ - particleData.positions[i3 + 2];
                const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
                
                // 吸引力（与距离成正比）
                const attractionStrength = ATTRACTION_FORCE * (distance > 0.1 ? distance : 0);
                particleData.accelerations[i3] = dx * attractionStrength;
                particleData.accelerations[i3 + 1] = dy * attractionStrength;
                particleData.accelerations[i3 + 2] = dz * attractionStrength;
                
                // 手部交互力（如果检测到手）
                if (handData.landmarks) {
                    // 深度推拉反馈：根据手掌大小缩放交互范围
                    const interactionRange = 3 + handData.handSize * 10;
                    
                    // 计算粒子到手中心的距离
                    const handDx = (handData.palmCenter.x - 0.5) * 20 - particleData.positions[i3];
                    const handDy = (0.5 - handData.palmCenter.y) * 20 - particleData.positions[i3 + 1];
                    const handDz = handData.palmCenter.z * 10 - particleData.positions[i3 + 2];
                    const handDistance = Math.sqrt(handDx * handDx + handDy * handDy + handDz * handDz);
                    
                    if (handDistance < interactionRange) {
                        // 挥手风暴交互：根据手部速度施加力
                        const handSpeed = Math.sqrt(
                            handData.velocity.x * handData.velocity.x +
                            handData.velocity.y * handData.velocity.y +
                            handData.velocity.z * handData.velocity.z
                        );
                        
                        if (handSpeed > 0.01) {
                            const stormForce = Math.min(handSpeed * 5, 2);
                            particleData.accelerations[i3] += handData.velocity.x * stormForce;
                            particleData.accelerations[i3 + 1] += -handData.velocity.y * stormForce;
                            particleData.accelerations[i3 + 2] += handData.velocity.z * stormForce;
                        }
                        
                        // 排斥力
                        const repulsionStrength = REPULSION_FORCE * (1 - handDistance / interactionRange);
                        particleData.accelerations[i3] -= (handDx / handDistance) * repulsionStrength;
                        particleData.accelerations[i3 + 1] -= (handDy / handDistance) * repulsionStrength;
                        particleData.accelerations[i3 + 2] -= (handDz / handDistance) * repulsionStrength;
                    }
                }
                
                // 更新速度（加速度积分）
                particleData.velocities[i3] += particleData.accelerations[i3];
                particleData.velocities[i3 + 1] += particleData.accelerations[i3 + 1];
                particleData.velocities[i3 + 2] += particleData.accelerations[i3 + 2];
                
                // 速度限制和阻尼
                const speed = Math.sqrt(
                    particleData.velocities[i3] * particleData.velocities[i3] +
                    particleData.velocities[i3 + 1] * particleData.velocities[i3 + 1] +
                    particleData.velocities[i3 + 2] * particleData.velocities[i3 + 2]
                );
                
                if (speed > MAX_VELOCITY) {
                    const scale = MAX_VELOCITY / speed;
                    particleData.velocities[i3] *= scale;
                    particleData.velocities[i3 + 1] *= scale;
                    particleData.velocities[i3 + 2] *= scale;
                }
                
                particleData.velocities[i3] *= DAMPING;
                particleData.velocities[i3 + 1] *= DAMPING;
                particleData.velocities[i3 + 2] *= DAMPING;
                
                // 更新位置（速度积分）
                particleData.positions[i3] += particleData.velocities[i3];
                particleData.positions[i3 + 1] += particleData.velocities[i3 + 1];
                particleData.positions[i3 + 2] += particleData.velocities[i3 + 2];
                
                // 更新Three.js缓冲区
                positions[i3] = particleData.positions[i3];
                positions[i3 + 1] = particleData.positions[i3 + 1];
                positions[i3 + 2] = particleData.positions[i3 + 2];
                
                // 根据速度调整颜色强度（保持圣诞主题）
                const colorIntensity = Math.min(0.6 + speed * 0.4, 1);
                // 保持原有的圣诞颜色比例，只调整亮度
                const baseR = particleData.colors[i3];
                const baseG = particleData.colors[i3 + 1];
                const baseB = particleData.colors[i3 + 2];
                colors[i3] = baseR * colorIntensity;
                colors[i3 + 1] = baseG * colorIntensity;
                colors[i3 + 2] = baseB * colorIntensity;
            }
            
            // 标记缓冲区需要更新
            particleSystem.geometry.attributes.position.needsUpdate = true;
            particleSystem.geometry.attributes.color.needsUpdate = true;
            
            // 深度推拉反馈：根据手掌大小调整粒子系统缩放
            if (handData.handSize > 0) {
                const scale = 0.5 + handData.handSize * 2;
                particleSystem.scale.setScalar(Math.min(scale, 3));
            }
        }
        
        // 计算目标形状
        function calculateTargetShape() {
            const transition = gestureTransitionProgress;
            
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;
                
                let targetX, targetY, targetZ;
                
                switch (currentGesture) {
                    case GESTURE_STATES.OPEN_HAND:
                        // 球形
                        const phi = Math.acos(-1 + (2 * i) / PARTICLE_COUNT);
                        const theta = Math.sqrt(PARTICLE_COUNT * Math.PI) * phi;
                        targetX = 5 * Math.cos(theta) * Math.sin(phi);
                        targetY = 5 * Math.sin(theta) * Math.sin(phi);
                        targetZ = 5 * Math.cos(phi);
                        break;
                        
                    case GESTURE_STATES.SCISSORS:
                        // 文字形状效果
                        const angle = (i / PARTICLE_COUNT) * Math.PI * 2;
                        const radius = 3 + Math.sin(angle * 5) * 0.5;
                        targetX = Math.cos(angle) * radius;
                        targetY = Math.sin(angle) * radius;
                        targetZ = Math.sin(i * 0.01) * 2;
                        break;
                        
                    case GESTURE_STATES.FIST:
                        // 圆环
                        const ringAngle = (i / PARTICLE_COUNT) * Math.PI * 2;
                        const ringRadius = 4;
                        targetX = Math.cos(ringAngle) * ringRadius;
                        targetY = Math.sin(ringAngle) * ringRadius;
                        targetZ = Math.sin(ringAngle * 2) * 0.3;
                        break;
                        
                    case GESTURE_STATES.POINTING:
                        // 星星
                        const starAngle = (i / PARTICLE_COUNT) * Math.PI * 2;
                        const starRadius = 3 + Math.sin(starAngle * 5) * 0.8;
                        targetX = Math.cos(starAngle) * starRadius;
                        targetY = Math.sin(starAngle) * starRadius;
                        targetZ = Math.sin(starAngle * 2) * 0.5;
                        break;
                        
                    case GESTURE_STATES.THUMBS_UP:
                        // 爱心
                        const t = (i / PARTICLE_COUNT) * Math.PI * 2;
                        const heartX = 4 * Math.pow(Math.sin(t), 3);
                        const heartY = 3 * Math.cos(t) - 1.3 * Math.cos(2 * t) - 0.6 * Math.cos(3 * t) - 0.2 * Math.cos(4 * t);
                        targetX = heartX;
                        targetY = heartY;
                        targetZ = Math.sin(t) * 0.5;
                        break;
                        
                    case GESTURE_STATES.CHRISTMAS_TREE:
                        // 圣诞树形状（更真实的层次结构）
                        const numLayers = 6; // 6层，更明显的层次
                        const trunkParticles = Math.floor(PARTICLE_COUNT * 0.05); // 5%的粒子用于树干
                        
                        if (i < trunkParticles) {
                            // 树干部分（底部中心）
                            const trunkHeight = 1.2;
                            const trunkRadius = 0.3;
                            const trunkProgress = i / trunkParticles;
                            const trunkAngle = (i / trunkParticles) * Math.PI * 2;
                            
                            targetY = -4 + trunkProgress * trunkHeight;
                            targetX = Math.cos(trunkAngle) * trunkRadius * (0.3 + trunkProgress * 0.7);
                            targetZ = Math.sin(trunkAngle) * trunkRadius * (0.3 + trunkProgress * 0.7);
                        } else {
                            // 树叶部分
                            const leafParticles = PARTICLE_COUNT - trunkParticles;
                            const leafIndex = i - trunkParticles;
                            const treeLayer = Math.floor((leafIndex / leafParticles) * numLayers);
                            const particlesPerLayer = leafParticles / numLayers;
                            const particleInLayer = leafIndex % particlesPerLayer;
                            const layerProgress = particleInLayer / particlesPerLayer;
                            
                            const treeHeight = 7.5;
                            const baseWidth = 4.0; // 底部更宽
                            
                            // 每层的高度和位置（有间隔，更真实）
                            const layerSpacing = treeHeight / (numLayers + 1);
                            const layerHeight = layerSpacing * 0.7; // 每层高度
                            const layerYBase = -4 + trunkParticles / PARTICLE_COUNT * 1.2 + treeLayer * layerSpacing;
                            targetY = layerYBase + layerProgress * layerHeight;
                            
                            // 每层的宽度递减（更自然的锥形曲线）
                            const layerWidthFactor = Math.pow(1 - treeLayer / numLayers, 0.7);
                            const layerWidth = baseWidth * layerWidthFactor;
                            
                            // 每层内的角度分布（圆形）
                            const treeAngle = (particleInLayer / particlesPerLayer) * Math.PI * 2;
                            
                            // 每层内的半径分布（从中心到边缘）
                            // 使用更密集的中心分布，模拟真实的树叶分布
                            const radiusFactor = Math.pow(layerProgress, 0.6); // 非线性分布
                            const treeRadius = layerWidth * (0.15 + radiusFactor * 0.85);
                            
                            targetX = Math.cos(treeAngle) * treeRadius;
                            targetZ = Math.sin(treeAngle) * treeRadius;
                            
                            // 树顶星星（最上层的一部分粒子，约20%）
                            if (treeLayer === numLayers - 1 && layerProgress > 0.8) {
                                const starPoints = 5;
                                const starIndex = particleInLayer - particlesPerLayer * 0.8;
                                const starProgress = starIndex / (particlesPerLayer * 0.2);
                                const starAngle = (starIndex % (particlesPerLayer * 0.2 / starPoints)) / (particlesPerLayer * 0.2 / starPoints) * Math.PI * 2;
                                const starRadius = 0.5 + Math.sin(starAngle * starPoints) * 0.3;
                                targetX = Math.cos(starAngle) * starRadius;
                                targetZ = Math.sin(starAngle) * starRadius;
                                targetY = layerYBase + layerHeight * 0.9;
                            }
                            
                            // 添加一些装饰品位置（随机分布在树上）
                            if (i % 50 === 0 && treeLayer > 0 && treeLayer < numLayers - 1) {
                                // 装饰品稍微突出
                                const decorAngle = Math.random() * Math.PI * 2;
                                const decorRadius = treeRadius * 1.15;
                                targetX = Math.cos(decorAngle) * decorRadius;
                                targetZ = Math.sin(decorAngle) * decorRadius;
                            }
                        }
                        break;
                        
                    default:
                        // 随机云状
                        targetX = (Math.random() - 0.5) * 10;
                        targetY = (Math.random() - 0.5) * 10;
                        targetZ = (Math.random() - 0.5) * 10;
                }
                
                // 应用过渡效果
                if (transition < 1 && transition > 0) {
                    const prevX = particleData.targets[i3];
                    const prevY = particleData.targets[i3 + 1];
                    const prevZ = particleData.targets[i3 + 2];
                    
                    particleData.targets[i3] = prevX * (1 - transition) + targetX * transition;
                    particleData.targets[i3 + 1] = prevY * (1 - transition) + targetY * transition;
                    particleData.targets[i3 + 2] = prevZ * (1 - transition) + targetZ * transition;
                } else {
                    particleData.targets[i3] = targetX;
                    particleData.targets[i3 + 1] = targetY;
                    particleData.targets[i3 + 2] = targetZ;
                }
            }
        }
        
        // 应用爆炸过渡特效
        function applyExplosionEffect() {
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;
                
                // 为每个粒子添加随机爆炸速度
                const explosionForce = 2;
                particleData.velocities[i3] += (Math.random() - 0.5) * explosionForce;
                particleData.velocities[i3 + 1] += (Math.random() - 0.5) * explosionForce;
                particleData.velocities[i3 + 2] += (Math.random() - 0.5) * explosionForce;
                
                // 短暂改变颜色为爆炸效果（金色闪光）
                particleData.colors[i3] = 1;      // 红色
                particleData.colors[i3 + 1] = 0.9; // 金色（高亮）
                particleData.colors[i3 + 2] = 0.3; // 少量蓝色
            }
            
            // 0.5秒后恢复圣诞主题颜色
            setTimeout(() => {
                for (let i = 0; i < PARTICLE_COUNT; i++) {
                    const i3 = i * 3;
                    // 恢复为圣诞主题颜色（70%红色，30%金色）
                    if (Math.random() < 0.7) {
                        particleData.colors[i3] = 1;      // 红色
                        particleData.colors[i3 + 1] = 0.1; // 少量绿色
                        particleData.colors[i3 + 2] = 0.1; // 少量蓝色
                    } else {
                        particleData.colors[i3] = 1;      // 红色
                        particleData.colors[i3 + 1] = 0.8; // 金色
                        particleData.colors[i3 + 2] = 0.2; // 少量蓝色
                    }
                }
            }, 500);
        }
        
        // ============ 动画循环与工具函数 ============
        
        // 动画循环
        function animate(currentTime) {
            animationId = requestAnimationFrame(animate);
            
            // 计算FPS
            frameCount++;
            if (currentTime - lastTime >= 1000) {
                fps = Math.round((frameCount * 1000) / (currentTime - lastTime));
                document.getElementById('fps').textContent = fps;
                frameCount = 0;
                lastTime = currentTime;
            }
            
            // 更新粒子物理
            updateParticles();
            
            // 更新圣诞树动画
            updateChristmasTree();
            
            // 更新控制器
            if (controls) {
                controls.update();
            }
            
            // 渲染场景
            if (renderer && scene && camera) {
                renderer.render(scene, camera);
            }
        }
        
        // 窗口大小调整处理
        function onWindowResize() {
            if (camera && renderer) {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
        }
        
        // ============ 初始化与事件绑定 ============
        
        // 初始化应用
        function init() {
            console.log("初始化WebAR粒子系统...");
            
            // 检查浏览器兼容性
            if (!window.WebGLRenderingContext) {
                document.getElementById('loading').innerHTML = 
                    "您的浏览器不支持WebGL，请使用Chrome、Edge或Firefox等现代浏览器";
                return;
            }
            
            // 绑定按钮事件
            document.getElementById('webcamButton').addEventListener('click', startWebcam);
            
            // 初始化Three.js
            initThreeJS();
            
            // 开始动画循环
            lastTime = performance.now();
            animate(lastTime);
            
            console.log("WebAR粒子系统初始化完成");
        }
        
        // 页面加载完成后初始化
        window.addEventListener('DOMContentLoaded', init);
        
        // 清理资源
        window.addEventListener('beforeunload', () => {
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
        });
    </script>
</body>
</html>